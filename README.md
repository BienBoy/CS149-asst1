# 作业1：四核CPU性能分析

**总分100 + 额外6分**

## 概述

这个作业旨在帮助你了解现代多核 CPU 中的两种主要并行执行形式：

1. 单个处理核内的 SIMD 执行
2. 使用多个核的并行执行（你也将看到 Intel 超线程的效果）

你还将获得测量和分析并行程序性能的经验（这是一项具有挑战性但非常重要的技能，你将在整个课程中使用）。项作业只涉及少量编程，但需要大量分析！

## 环境设置

**你需要在新的 myth 机器上运行代码以完成此作业。**（这些机器的主机名是 `myth[51-66].stanford.edu`）这些机器配备了四核 4.2 GHz 的 Intel Core i7 处理器（动态频率缩放可以在芯片认为有用且可能的情况下将频率提高到 4.5 GHz）。处理器中的每个核都支持两个硬件线程（英特尔称之为“超线程”），可以执行 AVX2 向量指令，这些指令描述了对多个单精度数据值同时执行相同八位操作的过程。对于好奇的同学，可以在[这里](https://ark.intel.com/products/97129/Intel-Core-i7-7700K-Processor-8M-Cache-up-to-4-50-GHz-)找到此 CPU 的完整规格。

注意：为了评分目的，我们希望你报告在 Stanford myth 机器上运行代码的性能，不过为了好玩，你也可以在你自己的机器上运行本作业中的程序。（你首先需要安装 Intel SPMD 程序编译器（ISPC），可以在这里下载：https://ispc.github.io/）。欢迎在报告中包含你在其他机器上运行代码的发现，只需非常清楚地说明你运行的机器是什么。

开始：

1. 本作业中使用的许多程序需要 ISPC 进行编译。可以通过以下步骤在 myth 机器上轻松安装 ISPC：

从 myth 机器中，将 Linux 二进制文件下载到你选择的本地目录。你可以从 ISPC 的[下载页面](https://ispc.github.io/downloads.html)获取 ISPC 编译器的 Linux 二进制文件。在从 `myth` 上，我们建议你使用 `wget` 直接从下载页面下载二进制文件：

```bash
wget https://github.com/ispc/ispc/releases/download/v1.21.0/ispc-v1.21.0-linux.tar.gz
```

解压下载的文件：`tar -xvf ispc-v1.12.2-linux.tar.gz`（你可能需要根据 ISPC 版本号相应地更改文件名）

将 ISPC 目录添加到系统路径中。例如，如果你将 ispc 复制到目录 `~/Downloads/ispc-v1.21.0-linux` 中，在 bash 中你可以通过以下命令更新路径变量：

```
export PATH=$PATH:~/Downloads/ispc-v1.21.0-linux
```

上述命令可以添加到`.bashrc`文件中以避免每次重新输入。

如果你使用 csh，可以使用 `setenv` 来更新 `PATH`。

2. 作业初始代码可在 [github] 上获取。请克隆作业 1 的启动代码：

```
git clone https://github.com/stanford-cs149/asst1.git
```

## 程序 1：使用线程并行生成分形图 (20 分) ##

在初始代码的 `prog1_mandelbrot_threads/` 目录中构建并运行代码：通过命令 `make` 进行构建，并通过命令  `./mandelbrot` 运行。此程序会生成名为 `mandelbrot-serial.ppm` 的图像文件，该文件是一个著名的复数集合 Mandelbrot 的可视化图像。大多数平台都有一个 .ppm 查看器。要远程查看生成的图像，需要安装 _X server_：Linux 系统不需要额外下载，Mac 可以使用 [Xquartz](https://www.xquartz.org/)，Windows 可以使用 [VcXsrv](https://sourceforge.net/projects/vcxsrv/)。在拥有 SSH X-Forwarding 支持后，确保你使用 `ssh -Y` 登录到 myth 机器，然后可以使用 `display` 命令查看图像。如下图所示，结果是一个熟悉且美丽的分形图。图像中的每个像素对应于复平面中的一个值，每个像素的亮度与确定该值是否包含在 Mandelbrot 中的计算成本成正比。要获得图像2，请使用命令选项 `--view 2`。（参见 `mandelbrotSerial.cpp` 中定义的函数 `mandelbrotSerial()`。）你可以在 <http://en.wikipedia.org/wiki/Mandelbrot_set> 上了解有关 Mandelbrot 的更多定义。

![Mandelbrot 集](handout-images/mandelbrot_viz.jpg "Mandelbrot 两种视图的可视化。计算每个像素的成本与其亮度成正比。在运行程序1和程序3时，你可以使用命令行选项 `--view 2` 将输出设置为视图2。")

你的任务是使用 [std::thread](https://en.cppreference.com/w/cpp/thread/thread) 并行化图像的计算。在 `mandelbrotThread.cpp` 中的 `mandelbrotThread()` 函数中提供了启动一个新线程的初始代码。在此函数中，主应用程序线程使用构造函数 `std::thread(function, args...)` 创建另一个线程。它通过调用线程对象的 `join` 来等待该线程完成。当前启动的线程不执行任何计算并立即返回。你应在 `workerThreadStart` 函数中添加代码以完成此任务。此作业中你不需要使用其他的 std::thread API。

**你需要做的事情：**

1. 修改起始代码，使用两个处理器并行化 Mandelbrot 图像生成。具体来说，在线程 0 中计算图像的上半部分，在线程1中计算图像的下半部分。因为图像的不同空间区域由不同的处理器计算，所以这种问题的分解方式称为 _空间分解_。
2. 扩展你的代码以使用2、3、4、5、6、7和8个线程，按照线程划分图像生成工作（线程应该获得图像的块）。注意，处理器只有四个核心，但每个核心支持两个超线程，因此它可以在其执行上下文中交替执行总共八个线程。在你的报告中，需要给出一张生成视图1时**相对于串行程序的加速比与线程数的关系**的图表。加速比是否随着使用线程数线性增长？在你的报告中猜测为什么会（或不会）这样？（你可能还需要为视图2绘制一个图表，以帮助你想出一个好的答案。提示：仔细查看三线程数据点。）
3. 为了证实（或反驳）你的假设，通过在 `workerThreadStart()` 的开头和结尾插入计时代码来测量每个线程完成其工作的时间。你的测试结果如何解释你之前创建的加速比图？
4. 修改线程的工作分配，以提高 Mandelbrot 两个视图的加速比到 __大约7-8倍__（如果超过7倍，不必担心）。在你的解决方案中不能使用任何线程间的同步。我们期望你提出一种适用于所有线程数的单一工作分解策略——不允许对每个配置硬编码特定的解决方案！（提示：有一种非常简单的静态分配方法可以实现这一目标，并且不需要线程之间的通信/同步。）在你的报告中，描述你的并行化方法并报告最终的 8 线程加速比。
5. 现在使用 16 个线程运行你的改进代码。性能是否明显高于使用八个线程时？为什么？

## 程序 2：使用 SIMD 内置函数向量化代码 (20 分)

请查看作业 1 所给代码中 `prog2_vecintrin/main.cpp` 中的 `clampedExpSerial` 函数。`clampedExp()` 函数将输入数组的所有元素 `values[i]` 提升到 `exponents[i]` 指定的幂次，并将结果值限制在 9.999999。在程序 2 中，你的任务是向量化这段代码，使其可以在支持 SIMD 向量指令的机器上运行。

然而，为了简化任务，我们并不要求你使用映射到现代 CPU 上真实 SIMD 向量指令的 SSE 或 AVX2 向量内置函数来实现，而是使用 `CS149intrin.h` 中定义的 CS149 的“虚拟向量内置函数”来实现。`CS149intrin.h` 库为你提供了一组在向量值和/或向量掩码上操作的向量指令。（这些函数不会转化为真实的 CPU 向量指令，而是我们在库中模拟这些操作，并提供易于调试的反馈。）在 `main.cpp` 中给出了一个使用 CS149 内置函数的 `abs()` 函数的向量化版本作为示例。此示例包含一些基本的向量加载和存储以及掩码寄存器的操作。注意，`abs()` 示例只是一个简单的例子，实际上代码并不能正确处理所有输入！（我们让你自己找出原因！）你可能需要阅读 `CS149intrin.h` 中的所有注释和函数定义，以了解可用的操作。

以下是一些帮助你实现的提示：

- 每个向量指令都受到可选掩码参数的约束。掩码参数定义了哪些通道在此操作中被“屏蔽”。掩码中的 0 表示通道被屏蔽，因此其值不会被向量操作的结果覆盖。如果操作中未指定掩码，则不屏蔽任何通道。（注意，这相当于提供了一个全为 1 的掩码。） *提示：* 你的解决方案需要使用多个掩码寄存器和库中提供的各种掩码操作。
- *提示：* 使用 `_cs149_cntbits` 函数在这个问题中会很有帮助。
- 考虑如果循环迭代的总数不是 SIMD 向量宽度的倍数会发生什么。我们建议你使用 `./myexp -s 3` 测试你的代码。 *提示：* 你可能会发现 `_cs149_init_ones` 有用。
- *提示：* 使用 `./myexp -l` 在程序结束时打印已执行向量指令的日志。使用 `addUserLog()` 函数在日志中添加自定义调试信息。可以自由添加额外的 `CS149Logger.printLog()` 以帮助你调试。

程序的输出将告诉你你的实现是否生成了正确的输出。如果有不正确的结果，程序将打印出第一个错误并打印出函数输入和输出的表格。你的函数输出位于 "output = " 之后，应与 "gold = " 之后的结果匹配。程序还打印出描述 CS149 虚拟向量单元利用率的统计信息。你可以将实现的性能视为“Total Vector 
Instructions”的值。（你可以认为每个 CS149 虚拟向量指令在 CS149 虚拟 SIMD CPU 上耗时一个周期。）“Vector Utilization”表示启用的向量通道的百分比。

**你需要做的事情：**

1. 在 `clampedExpVector` 中实现 `clampedExpSerial` 的向量化版本。你的实现应适用于任何大小(`N`) 和向量宽度 (`VECTOR_WIDTH`) 的输入数组。
2. 运行 `./myexp -s 10000` 并将向量宽度依次改为 2、4、8 和 16。记录生成的向量利用率（Vector Utilization）。你可以通过更改 `CS149intrin.h` 中的 `#define VECTOR_WIDTH` 值来做到这一点。随着 `VECTOR_WIDTH` 的变化，向量利用率是增加、减少还是保持不变？为什么？
3. *额外加分：（1 分）* 在 `arraySumVector` 中实现 `arraySumSerial` 的向量化版本。你的实现可以假设 `VECTOR_WIDTH` 是输入数组大小 `N` 的因数。虽然串行实现的运行时间是 `O(N)`，但你的实现的目标应为 `(N / VECTOR_WIDTH + VECTOR_WIDTH)` 或甚至 `(N / VECTOR_WIDTH + log2(VECTOR_WIDTH))`。你可能会发现 `hadd` 和 `interleave` 操作很有用。

## 程序 3：使用 ISPC 并行生成分形图 (20 分) ##

既然你已经熟悉了 SIMD 执行，我们将回到并行 Mandelbrot 分形图生成（类似于程序 1）。像程序 1 一样，程序 3 计算 Mandelbrot 分形图，但它通过利用 CPU 的四个核心和每个核心内的 SIMD 执行单元来实现更大的加速。

在程序 1 中，你通过为系统中的每个处理核心创建一个线程来并行化图像生成。然后，你将计算的部分分配给这些并发执行的线程。（由于程序 1 中的线程与处理核心是一对一对应的，所以你实际上将工作显式分配给核心。）而在程序 3 中，使用 ISPC 语言结构来描述*独立计算*。这些计算可以并行执行而不违反程序的正确性（事实上它们确实会并行执行）。对于 Mandelbrot 图，每个像素值的计算是独立的计算。基于此信息，ISPC 编译器和运行时系统负责生成尽可能高效地利用 CPU 并行执行资源的程序。

你将对用 C++ 和 ISPC 编写的程序 3 进行一个简单修复（这个错误会导致性能问题，而不是正确性问题）。通过正确修复，你应该会看到性能比原始的 `mandelbrotSerial()` 串行实现高出 32 倍以上。

### 程序 3，第 1 部分：一些 ISPC 基础知识（20 分中的 10 分） ###

阅读 ISPC 代码时，你必须记住，虽然代码看起来很像 C/C++ 代码，但 ISPC 执行模型与标准 C/C++ 的执行模型不同。与 C 不同，ISPC 程序的多个程序实例总是在 CPU 的 SIMD 执行单元上并行执行。同时执行的程序实例数量由编译器决定（根据底层机器选择）。这个并发实例数通过内置变量`programCount`提供给 ISPC 程序员。ISPC 代码可以通过内置的`programIndex`引用其自己的程序实例标识符。因此，从 C 代码调用 ISPC 函数可以被认为是生成一组并发的 ISPC 程序实例（在 ISPC 文档中称为一个 gang）。这组实例运行到完成，然后返回 C 中调用 ISPC 函数处。

__停一下。这是你友好的导师。请再次阅读前面的段落。相信我。__

例如，以下程序使用常规 C 代码和 ISPC 代码的组合来进行两个含 1024 元素的向量的加法。正如我们在课堂上讨论的，由于 gang 中的实例相互独立并都执行相同的程序逻辑，使用 SIMD 指令可以加速执行。

下面是一个简单的 ISPC 程序。以下 C 代码将调用以下 ISPC 代码：

    ------------------------------------------------------------------------
    C程序代码: myprogram.cpp
    ------------------------------------------------------------------------
    const int TOTAL_VALUES = 1024;
    float a[TOTAL_VALUES];
    float b[TOTAL_VALUES];
    float c[TOTAL_VALUES]
     
    // 在此初始化数组a和b。
     
    sum(TOTAL_VALUES, a, b, c);
     
    // 从sum返回后，a + b的结果存储在c中。

对应的 ISPC 代码：

    ------------------------------------------------------------------------
    ISPC代码: myprogram.ispc
    ------------------------------------------------------------------------
    export sum(uniform int N, uniform float* a, uniform float* b, uniform float* c)
    {
      // 假设N可以整除programCount。
      for (int i=0; i<N; i+=programCount)
      {
        c[programIndex + i] = a[programIndex + i] + b[programIndex + i];
      }
    }

上面的 ISPC 程序代码中，程序实例间交错处理数组元素。注意它与程序 1 的相似之处，在程序 1 中你静态地将图像的部分分配给线程。

然而，与其考虑如何在程序实例之间划分工作（即，如何将工作映射到执行单元），通常更方便且更强大的是只关注问题的独立部分的划分。ISPC 的`foreach`结构提供了一种机制来表示问题的分解。下面，ISPC 函数`sum2`中的`foreach`循环定义了一个迭代空间，其中所有迭代都是独立的，因此可以以任何顺序进行。ISPC 将循环迭代分配给并发的程序实例。`sum`和下面的`sum2`之间的区别是微妙但非常重要的。`sum`是命令式的：它描述了如何将工作映射到并发实例。下面的例子是声明式的：它仅指定要执行的工作集。

    -------------------------------------------------------------------------
    ISPC代码:
    -------------------------------------------------------------------------
    export sum2(uniform int N, uniform float* a, uniform float* b, uniform float* c)
    {
      foreach (i = 0 ... N)
      {
        c[i] = a[i] + b[i];
      }
    }

在继续之前，建议你通过阅读 [ISPC 演练](http://ispc.github.io/example.html) 熟悉 ISPC 语言结构。演练中的示例程序几乎与`mandelbrot.ispc`中的`mandelbrot_ispc()`实现完全相同。在作业的代码中，我们更改了`foreach`循环的边界，以得到更直观的实现。

**你需要做的事情：**

1.  编译并运行程序 mandelbrot ispc。**ISPC 编译器当前配置为发出 8 宽度的 AVX2 向量指令。** 鉴于你对这些 CPU 的了解，你期望的最大加速比是多少？
	为什么你观察到的数字可能比这个理想值要小？（提示：考虑你正在执行的计算的特征？描述图像的哪些部分对 SIMD 执行构成挑战？比较不同视图的 Mandelbrot 集的渲染性能可能有助于确认你的假设。）

我们提醒你，对于本节描述的代码，ISPC 编译器将程序实例的 gang 映射到在单个核心上执行的 SIMD 指令。这种并行化方案不同于程序 1：程序1中通过在多个核心上运行线程来实现加速。

如果你查阅关于 myth 机器上的 CPU 的详细技术资料，你会发现关于每个时钟可以运行多少标量和向量指令有一套复杂的规则。对于本作业，你可以假设有 8 宽度向量执行单元的数量与浮点数学的标量执行单元的数量大致相同。

### 程序 3，第 2部分：ISPC 任务（20 分中的 10 分） ###

ISPC 的 SPMD 执行模型和`foreach`等机制促进了利用 SIMD 处理的程序的创建。该语言还提供了一种利用多个核心进行 ISPC 计算的补充机制——启动（launch）*ISPC任务*。

请参见函数`mandelbrot_ispc_withtasks`中的`launch[2]`命令。此命令启动了两个任务。每个任务定义了一个将由一组 ISPC 程序实例执行的计算。正如函数`mandelbrot_ispc_task`那样，每个任务计算最终图像的一个区域。类似于`foreach`结构定义的可以以任何顺序执行（并由 ISPC 程序实例并行执行）的循环迭代，启动操作创建的任务可以以任何顺序处理（并在不同的 CPU 核心上并行处理）。

**你需要做的事情：**

1.  使用参数`--tasks`运行`mandelbrot_ispc`。你在视图 1 上观察到的加速比是多少？与未将计算分区为任务的`mandelbrot_ispc`版本相比，加速如何？
2.  通过更改函数`mandelbrot_ispc_withtasks()`中代码创建的任务数量，可以简单地提高`mandelbrot_ispc --tasks`的性能。你应该能够通过仅更改`mandelbrot_ispc_withtasks()`函数中的代码，使性能超过串行版本的代码 32 倍以上！
	你是如何确定要创建的任务数量的？为什么你选择的数量效果最好？
3.  *额外加分：（2 分）* 线程抽象（在程序 1 中使用）和 ISPC 任务抽象之间有什么区别？在（create/join）和（launch/sync）机制之间存在一些明显的语义差异，但这些差异的影响更为微妙。这里有一个思维实验来指导你的回答：当你启动10,000个 ISPC 任务时会发生什么？当你启动 10,000 个线程时会发生什么？（对于这个思维实验，请在一般情况下讨论，不要将讨论与这个给定的 mandelbrot 程序联系起来。）

_聪明学生的问题_：嘿，等一下！为什么有两种不同的机制（`foreach`和`launch`）向 ISPC 系统表示独立的、可并行化的工作？系统不能只划分`foreach`的许多迭代，并在所有核心上分配，同时为核心发出适当的 SIMD 代码吗？

_回答_：好问题！有很多可能的答案。来办公室时间讨论。

## 程序 4：迭代实现的`sqrt` (15 分) ##

程序 4 是一个 ISPC 程序，用于计算 2000 万个 0 到 3 之间的随机数的平方根。它通过快速迭代求解平方根：利用牛顿法求解方程 ${\frac{1}{x^2}} - S = 0$。在这个实现中，使用 1.0 作为初始猜测值。下图显示了`sqrt`在（0-3）范围内收敛到准确解所需的迭代次数。（对于该范围之外的输入值，程序不会收敛）。请注意，收敛速度取决于初始猜测值的准确性。

注意：这个问题是对前面学习内容的复习，旨在检查你的理解，因为它涵盖了与程序 2 和 3 类似的概念。

![sqrt收敛](handout-images/sqrt_graph.jpg "从1.0开始猜测时在0-3范围内sqrt的收敛情况。注意对于输入值为1时，收敛是即时的，而当输入值趋近于0或3时，迭代次数增加（最高值为输入值为3时）。")

**你需要做的事情：**

1.  构建并运行`sqrt`。观察 ISPC 实现使用单个 CPU 核心（无任务）和使用所有核心（有任务）时的加速比。SIMD 并行化带来的加速比是多少？多核心并行化带来的加速比是多少？
2.  修改数组的内容，以提高 ISPC 实现的相对加速比。构造一个特定输入，**最大化相对串行版本的加速比**，并报告所实现的加速比（对于有任务和无任务的 ISPC 实现）。你的修改是否提高了 SIMD 加速比？它是否提高了多核加速比（即，从无任务的 ISPC 移动到有任务的 ISPC 的收益）？请解释原因。
3.  构造一个特定输入，使得`sqrt`的 ISPC（无任务）相对于代码的串行版本**加速比最小化**。描述这个输入，描述你选择它的原因，并报告 ISPC 实现的相对性能。效率损失的原因是什么？
	**(请记住，我们使用的是`--target=avx2`选项来生成 8 宽度的 SIMD 指令)**。
4.  _额外加分：（最多2分）_ 使用 AVX2 内置函数手动编写你自己的`sqrt`函数版本。要获得加分，你的实现应该几乎与 ISPC 生成的二进制文件一样快（或更快）。你可能会发现 [Intel Intrinsics Guide](https://software.intel.com/sites/landingpage/IntrinsicsGuide/) 非常有帮助。

## 程序 5：BLAS `saxpy` (10 分) ##

程序 5 是 BLAS（基本线性代数子程序）库中`saxpy`例程的实现，该库在许多系统中广泛使用（并经过高度优化）。`saxpy`计算一个简单的操作`result = scale*X + Y`，其中`X`、`Y`和`result`是包含`N`个元素的向量（在程序 5 中，`N` = 2000万），`scale`是一个标量。注意，`saxpy`对于每三个元素执行两个数学运算（一个乘法，一个加法）。`saxpy`是一个*显然可并行化的计算*，具有可预测的、规律的数据访问和可预测的执行成本。

**你需要做的事情：**

1. 编译并运行`saxpy`。程序将报告`saxpy`的 ISPC（无任务）和 ISPC（有任务）实现的性能。使用有任务的 ISPC 所观察到的加速比是多少？解释该程序的性能。你认为它可以大幅改进吗？（例如，你可以重写代码以实现接近线性加速吗？是或否？请证明你的答案合理性。）
2. __额外加分：__（1 分）注意，`main.cpp`中计算消耗的总内存带宽为 `TOTAL_BYTES = 4 * N * sizeof(float);`。尽管`saxpy`从`X`加载一个元素，从`Y`加载一个元素，并将一个元素写入`result`，乘以 4 是正确的。为什么是这种情况？（提示，想想 CPU 缓存的工作原理。）
3. __额外加分：__（根据具体情况给分）提高`saxpy`的性能。我们希望看到显著的加速，而不仅仅是几个百分点。如果成功，请描述你是如何做到的，以及在这些系统上可能实现的最佳实现。如果成功，请告诉工作人员，我们会很感兴趣。;-)

注意：一些学生在这个问题上遇到了困难（思考过度）。我们期望一个简单的答案，但运行这个问题的结果可能会引发你更多的问题。鼓励你来和工作人员讨论。

## 程序 6：加速`K-Means`（15分）

程序 6 使用 K-Means 数据聚类算法（[维基百科](https://en.wikipedia.org/wiki/K-means_clustering)，[CS 221讲义](https://stanford.edu/~cpiech/cs221/handouts/kmeans.html)）对一百万个数据点进行聚类。如果你不熟悉这个算法，不用担心！具体细节对于这个练习并不重要，但从高层次上讲，给定 K 个起始点（簇质心），该算法会迭代地更新质心，直到满足收敛标准。结果可以从程序开始和结束时的状态图中看到，其中红色星星是簇质心，数据点的颜色对应于簇分配。

![K-Means开始和结束点](./handout-images/kmeans.jpg "K-Means算法应用于二维数据时开始和结束的状态图")

在起始代码中，你已经得到了 K-means 算法的正确实现，但是在当前状态下，它的速度还不如我们期望的那么快。这就是你需要介入的地方！你的任务是找出实现需要改进的地方，并**如何**改进。你在这个问题中练习的关键技能是**隔离性能热点**。我们不会告诉你在代码中该查找哪里，你需要自己找出来。你首先应该想到的是代码在哪里花费了最多的时间，并插入计时代码进行测量。基于这些测量结果，你应该关注占用运行时间较多的代码，然后仔细了解它，以确定是否有加速的方法。

**你需要做的事情：**

1. 使用命令 `ln -s /afs/ir.stanford.edu/class/cs149/data/data.dat ./data.dat` 在你的当前目录下创建一个指向数据集的符号链接（确保你在 `prog6_kmeans` 目录下）。这是一个大文件（约800MB），所以这是访问它的首选方式。不过，如果你想要一个本地副本，你可以在你的个人机器上运行此命令 `scp [Your SUNetID]@myth[51-66].stanford.edu:/afs/ir.stanford.edu/class/cs149/data/data.dat ./data.dat`。获得数据后，编译并运行 `kmeans`（第一次尝试运行程序时加载数据可能需要较长时间）。程序将报告算法在数据上的总运行时间。
2. 运行 `pip install -r requirements.txt` 下载必要的绘图包。接下来，尝试运行 `python3 plot.py`，它将根据运行 `kmeans` 生成的日志（"start.log" 和 "end.log"）生成文件 "start.png" 和 "end.png"。这些文件将在当前目录中，应该与上面的图像相似。__警告：你可能会注意到，并非所有点都被分配到“最近”的质心。这没关系。__（对于那些想要理解为什么的人：我们使用 [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis) 将 100 维数据点投影到2维，以生成这些可视化图像。因此，虽然100维数据点在高维空间中接近适当的质心，但数据点和质心的投影在2维中可能并不接近。）。只要聚类看起来“合理”（使用步骤 2 中的起始代码生成的图像作为参考），并且大多数点似乎被分配到最近的质心，代码仍然是正确的。
3. 利用 `common/CycleTimer.h` 中的计时函数确定代码中存在性能瓶颈的地方。你需要调用 `CycleTimer::currentSeconds()`，它返回当前时间（以秒为单位）作为浮点数。代码的大部分时间花在哪里了？
4. 基于上一步的发现，改进实现。我们希望看到大约 2.1 倍或更高的加速比（即 $\frac{oldRuntime}{newRuntime} >= 2.1$）。请解释你如何得出解决方案，以及最终的解决方案和对应的加速比。这个过程的报告应描述一系列步骤。我们期望的形式是“我测量了...，这让我认为X。因此，为了改进，我尝试了...，导致了...的加速/减速”。

约束：

- 你只能修改 `kmeansThread.cpp` 中的代码。你不能修改 `stoppingConditionMet` 函数，并且不能更改 `kMeansThread` 的接口，但其他内容都可以修改（例如，你可以向 `WorkerArgs` 结构体添加新成员，重写函数，分配新数组等）。但是...
- **确保你不改变实现的功能！如果算法没有收敛，或者运行 `python3 plot.py` 生成的结果与起始代码生成的不一样，那就说明有问题！** 例如，你不能简单地删除主“while”循环或更改 `dist` 函数的语义，因为这会导致结果不正确。
- __重要：__ 你只能并行化以下函数之一：`dist`，`computeAssignments`，`computeCentroids`，`computeCost`。有关如何使用 `std::thread` 编写并行代码的示例，请参见 `prog1_mandelbrot_threads/mandelbrotThread.cpp`。

提示/注意事项：

- 这个问题不应该需要大量的编码。我们的解决方案修改/添加了大约20-25行代码。
- 一旦你使用计时器隔离了热点代码，要改进代码，确保你了解 K、M 和 N 的相对大小。
- 尝试优先考虑具有高回报潜力的代码改进，并考虑问题中可用的不同并行轴以及如何利用它们。
- **这个程序的目的是让你更多地练习学习如何分析和调试性能导向的程序。即使你没有达到性能目标，如果你在报告中展示了良好/周到的调试技能，你仍然可以获得大部分分数。**

## 基于ARM的Mac

对于那些可以使用新的 Apple ARM 架构笔记本电脑的人，尝试在程序 3、4 和 5 中将 ISPC 编译目标更改为 `neon-i32x8`，并将编译架构更改为 `aarch64`。其他程序只使用 GCC，应该会生成正确的目标。在新的 Apple ARM 笔记本电脑上生成各个程序性能的报告。工作人员对你的发现很感兴趣。你在 SIMD 执行中观察到什么样的加速效果？没有现代 Macbook 的人可以尝试使用云提供商（如 AWS）上可用的基于 ARM 的服务器，尽管工作人员没有对此进行测试。

## 对于好奇心强的同学（强烈推荐）

想了解 ISPC 及其创建过程吗？ISPC 的两位创作者之一 Matt Pharr 写了一篇__非常精彩的博客文章__，讲述了其开发历史，名为 [The story of ispc](https://pharr.org/matt/blog/2018/04/30/ispc-all)。它确实触及了许多并行系统设计的问题——特别是有限范围与通用编程语言的价值。恕我直言，对于 CS149 的学生来说，这是必读的！

## 提交说明

提交将通过 [Gradescope](https://www.gradescope.com) 进行。每组只需提交一次。但是，请确保在 Gradescope 提交中添加你合作伙伴的名字。你需要在 Gradescope 上的两个地方提交文件：`Assignment 1 (Write-Up)` 和 `Assignment 1 (Code)`。

请在 `Assignment 1 (Write-Up)` 中放置以下内容：

* 你的报告，文件名为 `writeup.pdf`。请确保文件中包含两位组员的名字和 SUNet id。（如果你是两人小组）

请在 `Assignment 1 (Code)` 中放置以下内容：

* 你在程序 2 中实现的 `main.cpp`，文件名为 `prob2.cpp`
* 你在程序 6 中实现的 `kmeansThread.cpp`，文件名为 `prob6.cpp`
* 任何其他代码，例如，因为你尝试了额外的加分任务

请在你的报告中告诉助教查找你的额外加分内容。提交时，所有代码必须在 myth 机器上可以编译和运行！

## 资源和备注

- 广泛的 ISPC 文档和示例可以在<http://ispc.github.io/>找到
- 放大曼德尔布罗特图像的不同位置非常有趣
- 英特尔在<http://software.intel.com/en-us/avx/>上提供了许多关于 AVX2 向量指令的支持材料
- [Intel Intrinsics Guide](https://software.intel.com/sites/landingpage/IntrinsicsGuide/) 非常有用